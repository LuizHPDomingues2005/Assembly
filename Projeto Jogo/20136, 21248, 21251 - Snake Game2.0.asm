; Snake Game em Assembly 8086
; INI 51 - Professor Sergio Luiz Moral Marques
;
; Made  by
;
; Gustavo Mendes Oliveira             - RA: 20136
; Luiz Henrique Parolim Domingues     - RA: 21248
; Matheus Henrique de Oliveira Freire - RA: 21251
.MODEL SMALL
.STACK 100h
.DATA
    titleGame    DB "SNAKE GAME",13,10,"$"
    msgStart     DB "PRESSIONE QUALQUER TECLA PARA JOGAR",0Ah, "        OU [ESC] 2 VEZES PARA SAIR",13,10,"$"
    msgGameOver  DB "VOCE PERDEU!",13,10,"$"
    msgHowToPlay DB "USE 'WASD' PARA JOGAR",13,10,"$"
.CODE
START:
    CALL CLEAR_SCREEN; LIMPAMOS A TELA

    ; ISSO E NECESSARIO PARA CONSEGUIRMOS PRINTAR AS STRINGS
    MOV AX,@DATA 
    MOV DS,AX

    TITLE_GAME:
        ; USAMOS A FUNCAO AH = 02h COM INT10h
        ; PARA MUDAR O CURSORDE POSICAO

        ; LEMBRANDO QUE DH = LINHA
        ;               DL = COLUNA

        ; SET POSICAO DO CURSOR
        MOV AH, 02h
        MOV DX, 070Eh
        INT 10h

        ; PRINTANDO A MENSAGEM DE TITULO DO JOGO
        MOV DX, OFFSET titleGame
        MOV AH, 09h
        INT 21h

        ; SET POSICAO DO CURSOR
        MOV AH, 02h
        MOV DX, 0B03h
        INT 10h

        ; PRINTANDO A MENSAGEM DE INTRUCAO PARA INICIAR O JOGO
        MOV DX, OFFSET msgStart
        MOV AH, 09h
        INT 21h

        ; SET POSICAO DO CURSOR
        MOV AH, 02h
        MOV DX, 1801h
        INT 10h

        ; PRINTANDO A MENSAGEM DE INTRUCAO DE TECLAS DO JOGO
        MOV DX, OFFSET msgHowToPlay
        MOV AH, 09h
        INT 21h

        CALL HIDE_CURSOR ; ESCONDEMOS O CURSOR
        
    CALL READ_BUFFER
    INT 21h

    JMP PREPARE_GAME
PREPARE_GAME:

    CALL CLEAR_SCREEN; LIMPAMOS A TELA

    ; INICIALIZAR O REGISTRADOR ES COM O ENDERECO DO VIDEO B800h
    MOV AX, 0B800h ; -> ENDERECO DE MEMORIA DE VIDEO
    MOV ES, AX


    MOV SI, 1080     ; ALOCAMOS O PONTEIRO DO CURSOR NO CENTRO DA TELA

    XOR DI, DI ; -> ZERAMOS O PONTEIRO DAS 
               ;    POSICOES DA MEMORIA DE VIDEO
    XOR DX, DX ; ZERAMOS DX PARA VERIFICAR INICIO DO JOGO

GAME_LOOP: ; ================================ GAME LOOP ==================================
    CMP DL, 00h     ; SE DL FOR 00, OU SEJA, O JOGADOR NAO COMECOU A JOGAR
        JE CONTINUE ; NAO VAI PRINTAR NADA OU FAZER VERIFICACAO DE COLISAO

    ; LEMBRANDO NA MEMORIA DE VIDEO
    ; AH -> ATRIBUTO DO CARACTER
    ; AL -> CARACTER.
    MOV AX, 02DBh

    MOV DI, SI
    MOV [ES]:DI, AX

CONTINUE:
    ; CHAMAMOS O PROCEDIMENTO DE DELAY VARIAS VEZES
    ; POR NOSSOS PROCESSADORES SEREM POTENTES E O JOGO
    ; FICAR RAPIDO DEMAIS SEM ELES
    CALL DELAY
    CALL DELAY
    CALL DELAY

    CALL READ_BUFFER ; SEMPRE CHAMAREMOS O PROCEDIMENTO PARA LER DO TECLADO
    CALL CHECK_COLISION
    
CHECK_PRESSED_KEYS:
    ; =======================================================
    ; NOTA: 
    ;   IREMOS COMPARAR A TECLA DIGITADA COM AS
    ;   TECLAS MAIS USADAS EM JOGOS (WASD)
    ;   COMO DIRECIONAIS

    ;   PARA ESQUERDA E DIREITA USAREMOS APENAS INTRUCOES SIMPLES
    ;   DE OPERADORES UNARIOS DE INCREMENTAR E DECREMENTAR O VALOR DO
    ;   PONTEIRO DO CURSOR

    ;   PARA CIMA E PARA BAIXO, DEMOS LEVAR EM CONSIDERACAO QUE UMA
    ;   LINHA POSSUI 80 CARACTERES, POR ISSO USAMOS OPERADORES
    ;   BINARIOS PARA SOMAR OU SUBTRAIR 80 DO PONTEIRO NESSES CASOS.
    ; =======================================================
    CMP DL, 'w'
        JE UP
    CMP DL, 'a'
        JE LEFT
    CMP DL, 's'
        JE DOWN
    CMP DL, 'd'
        JE RIGHT        

    CMP DL, 1Bh  ; COMPARA SE DIGITOU ESC PARA SAIR
        JE  CLOSE_GAME   ; SE DIGITOU ESC SAI DO JOGO

    JMP GAME_LOOP ; REPETE O JOGO
UP:
    ; PARA IR PARA A LINHA DE CIMA, SUBTRAIMOS 80 DO PONTEIRO
    SUB SI, 80 
    JMP GAME_LOOP
DOWN:
    ; PARA IR PARA A LINHA DE BAIXO, SOMAMOS 80 DO PONTEIRO
    ADD SI, 80
    JMP GAME_LOOP
RIGHT:
    ; PARA IR PARA A DIREITA, SOMAMOS 2 NO VALOR NO PONTEIRO
    ADD SI, 2
    JMP GAME_LOOP
LEFT:
    ; PARA IR PARA A ESQUERDA, SUBTRAIMOS 2 NO VALOR NO PONTEIRO
    SUB SI, 2
    JMP GAME_LOOP
GAME_OVER:
    MOV AX, @DATA
    MOV DS, AX

    CALL CLEAR_SCREEN

    ; SET POSICAO DO CURSOR
    MOV AH, 02h
    MOV DX, 060Eh
    INT 10h

    ; PRINTANDO A MENSAGEM DE FIM DE JOGO
    MOV DX, OFFSET msgGameOver
    MOV AH, 09h
    INT 21h

    ; SET POSICAO DO CURSOR
    MOV AH, 02h
    MOV DX, 0B03h
    INT 10h

    ; PRINTANDO A MENSAGEM DE INTRUCAO PARA INICIAR O JOGO
    MOV DX, OFFSET msgStart
    MOV AH, 09h
    INT 21h

    CALL HIDE_CURSOR ; ESCONDEMOS O CURSOR

    CALL READ_BUFFER
    INT 21h

    JMP PREPARE_GAME

CLOSE_GAME: ; FIM DO PROGRAMA

    ; LIMPAMOS A TELA


    ; VOLTAMOS O CURSOR PARA UMA POSICAO VISIVEL PARA
    ; O USUARIO VER A MENSAGEM DO DOS
    MOV AH, 02h
    MOV DX, 0201h
    INT 10h

    MOV AX, 4C00h
    INT 21h

;============================ PROCEDIMENTOS =======================================================

CHECK_COLISION PROC ; CHECAR COLISAO = FIM DE JOGO
    ; ============= CHECAR FIM DE TELA ===============
    CMP SI, 0   ; SE PASSOU DO LIMITE DA PARTE DE CIMA DA TELA
        JB GAME_OVER

    CMP SI, 1998 ; SE PASSOU LIMITE DE BAIXO DA TELA
        JA GAME_OVER

    ; =========== CHECAR COLISAO COM CORPO DA COBRA =============
    XOR AX, AX ; ZERAMO AX POIS SERA USADO NESSA VERIFICACAO
    ; COLOCAMOS O O VALOR DA COR DA COBRA EM AH
    MOV AH, 0DBh

    ; VERIFICAMOS A DIRECAO DA COBRA POIS O PONTEIRO DO CURSOR PODE FAZER A VERIFICAO SER COMPROMETIDA
    VERIFY_DIRECTION:
        CMP DL, 'w'
            JE WLKING_UP
        CMP DL, 'a'
            JE WLKING_LEFT
        CMP DL, 's'
            JE WLKING_DOWN
        CMP DL, 'd'
            JE WLKING_RIGHT

    WLKING_UP:
        MOV AL, [ES]:SI-80
        JMP CONTINUE_COLLISION_CHECK
    WLKING_LEFT:
        MOV AL, [ES]:SI-2
        JMP CONTINUE_COLLISION_CHECK
    WLKING_DOWN:
        MOV AL, [ES]:SI+80
        JMP CONTINUE_COLLISION_CHECK
    WLKING_RIGHT: 
        MOV AL, [ES]:SI+2
        JMP CONTINUE_COLLISION_CHECK

    CONTINUE_COLLISION_CHECK:
    CMP AH, AL      ; COMPARAMOS A POSICAO ATUAL DA COBRA COM A COR DA COBRA
        JE GAME_OVER ; SE FOR IGUAL, SIGNIFCA QUE SUA POSICAO ATUAL JA FOI PASSADA ANTERIORMENTE
                    ; CONFIGURANDO FIM DE JOGO
    RET
ENDP

READ_BUFFER PROC
    XOR AX, AX ; LIMPAMOS AX PARA NAO COMPROMETER A LEITURA DE TECLADO

    ; LER DADOS DO TECLADO SEM SER AUTO BLOCANTE.
    MOV AH, 1      ; DEFINIR FUNÇÃO 1H DA INTERRUPÇÃO 16H (VERIFICAÇÃO DE TECLADO)
    INT 16H        ; CHAMAR A INTERRUPÇÃO 16H
        JZ NO_KEY_PRESS ; VERIFICAR SE NENHUMA TECLA FOI PRESSIONADA
    MOV AH, 0      ; DEFINIR FUNÇÃO 0H DA INTERRUPÇÃO 16H (LEITURA DO TECLADO)
    INT 16H        ; CHAMAR A INTERRUPÇÃO 16H

    JMP KEY_PRESSED
    ; O CARACTERE ASCII DA TECLA PRESSIONADA ESTARA EM AL
    ; SE ALGUMA TECLA FOI PRESSIONADA
    KEY_PRESSED:
        ; AQUI IREMOS COMPARAR SE A TECLA PRESSIONADA E VALIDA
        ; PARA MOVER AL PARA DL CORRETAMENTE E
        ; NAO QUEBRAR O PROGRAMA OU TRAVAR O JOGO
        CMP_VALID_KEYS:
            CMP AL, 'w'
                JE KEY_IS_VALID
            CMP AL, 'a'
                JE KEY_IS_VALID
            CMP AL, 's'
                JE KEY_IS_VALID
            CMP AL, 'd'
                JE KEY_IS_VALID 

            CMP AL, 1Bh  ; COMPARA SE DIGITOU ESC PARA SAIR
                JE KEY_IS_VALID   ; SE DIGITOU ESC SAI DO JOGO

            ; SE NENHUMA DAS TECLAS COMPARADAS ACIMA TIVEREM SIDO DIGITADAS
            ; PULA PARA O LABEL ONDE NENHUMA TECLA FOI DIGITADA

            JMP KEY_IS_NOT_VALID
        KEY_IS_VALID:
            MOV DL, AL ; MOVEMOS AL PARA DL PARA MAIOR SEGURANCA EM SALVAR A ULTIMA TECLA SALVA
            XOR AH, AH
        KEY_IS_NOT_VALID:
            ; NAO FAZ NADA, IGNORANDO A TECLA INVALIDA
    NO_KEY_PRESS:
        ; NAO FAZ NADA, DEIXANDO O JOGO RODAR SEM ALTERAR DL
        ; E CONSEQUENTEMENTE SEM ALTERAR
        ; A DIRECAO DA COBRA OU SAIR DO JOGO
    RET
ENDP

DELAY PROC ; PROCEDIMENTO DE DELAY PARA O JOGO
    MOV CX, 65535 ; 65535 E O VALOR MAXIMO QUE CX PODE CHEGAR
    DELAYLOOP:
        ; ENTRA EM LOOPING ATE CX VALER 0
        CMP AX, 0
        LOOP DELAYLOOP
        RET
ENDP

CLEAR_SCREEN PROC
    ; USAMOS A FUNCAO AH = 00h(SET VIDEO MODE) E AL = 00h(MODO DE VIDEO)
    ; COM O INTERRUPTOR 10h PARA LIMPAR A TELA
    MOV AX, 0000h
    INT 10h

    CALL HIDE_CURSOR

    RET
ENDP

HIDE_CURSOR PROC
    ; ESCONDEMOS O CURSOR MUDANDO PARA ABAIXO DA TELA VISIVEL
    MOV AH, 02h
    MOV DH, 0DBh
    INT 10h

    RET
ENDP

END START